var searchIndex = {};
searchIndex["wright"] = {"doc":"","items":[[0,"parser","wright","Parser module for Wright. Includes preliminary lexer function.",null,null],[3,"Parser","wright::parser","Parser struct.",null,null],[12,"module","","",0,null],[12,"original_content","","",0,null],[12,"lexer","","",0,null],[4,"ParserError","","",null,null],[13,"UnexpectedToken","","",1,null],[13,"MissingExpectedToken","","",1,null],[13,"InvalidAssignmentTarget","","",1,null],[0,"ast","","Abstract Syntax Tree Representation",null,null],[3,"UnaryExpr","wright::parser::ast","Unary Expression.",null,null],[12,"operator","","",2,null],[12,"right","","",2,null],[3,"BinaryExpr","","Binary Expression.",null,null],[12,"left","","",3,null],[12,"operator","","",3,null],[12,"right","","",3,null],[3,"Literal","","Literal struct.",null,null],[12,"literal","","",4,null],[3,"Identifier","","Identifier struct.",null,null],[12,"id","","",5,null],[12,"declared_type","","",5,null],[3,"Call","","Function call.",null,null],[12,"callee","","",6,null],[12,"args","","",6,null],[3,"Assignment","","Assignment statement.",null,null],[12,"left","","",7,null],[12,"assign_type","","",7,null],[12,"right","","",7,null],[3,"Block","","Block of statements",null,null],[12,"statements","","",8,null],[3,"Condition","","Single conditional statement.",null,null],[12,"condition","","",9,null],[12,"block","","",9,null],[3,"Conditional","","Conditional block",null,null],[12,"conditions","","",10,null],[3,"WhileLoop","","While loop struct.",null,null],[12,"condition","","",11,null],[12,"block","","",11,null],[3,"ForLoop","","For loop struct.",null,null],[12,"assignment","","",12,null],[12,"source_var","","",12,null],[12,"block","","",12,null],[3,"FunctionDefinition","","Function defining struct.",null,null],[12,"id","","",13,null],[12,"args","","",13,null],[12,"block","","",13,null],[3,"ClassDeclaration","","Class declaration struct.",null,null],[12,"id","","",14,null],[12,"traits_implemented","","",14,null],[12,"block","","",14,null],[3,"TraitDeclaration","","Class declaration struct.",null,null],[12,"id","","",15,null],[12,"block","","",15,null],[3,"EnumDeclaration","","Class declaration struct.",null,null],[12,"id","","",16,null],[12,"variants","","",16,null],[3,"Constant","","Constant struct.",null,null],[12,"id","","",17,null],[12,"val","","",17,null],[3,"Return","","Return statement struct.",null,null],[12,"val","","",18,null],[3,"Break","","Break statement struct.",null,null],[12,"identifier","","",19,null],[12,"val","","",19,null],[3,"Continue","","Continue statement struct.",null,null],[3,"Module","","Module struct Module is not in `Statement` because users should not be able to define modules in a file. Each Wright file should be it's own independent Module.",null,null],[12,"id","","",20,null],[12,"content","","",20,null],[4,"Expr","","Expression enum.",null,null],[13,"Unary","","",21,null],[13,"Binary","","",21,null],[13,"Literal","","",21,null],[13,"Identifier","","",21,null],[13,"FunctionCall","","",21,null],[13,"SingleCondition","","",21,null],[13,"Conditional","","",21,null],[4,"UnaryOperator","","Unary Operators",null,null],[13,"Not","","",22,null],[13,"Negative","","",22,null],[4,"BinaryOperator","","Enum representing binary operators.",null,null],[13,"Arithmetic","","",23,null],[13,"Logical","","",23,null],[13,"Relational","","",23,null],[4,"ArithmeticOperator","","Arithmetic Operators",null,null],[13,"Add","","",24,null],[13,"Subtract","","",24,null],[13,"Multiply","","",24,null],[13,"Divide","","",24,null],[13,"Modulo","","",24,null],[13,"BitwiseAnd","","",24,null],[13,"BitwiseOr","","",24,null],[13,"BitwiseXor","","",24,null],[13,"LeftShift","","",24,null],[13,"RightShift","","",24,null],[13,"Increment","","",24,null],[13,"Decrement","","",24,null],[4,"LogicalOperator","","Logical Operators",null,null],[13,"And","","",25,null],[13,"Or","","",25,null],[13,"Xor","","",25,null],[13,"ShortAnd","","",25,null],[13,"ShortOr","","",25,null],[4,"RelationalOperator","","Relational Operators",null,null],[13,"Equal","","",26,null],[13,"NotEqual","","",26,null],[13,"GreaterThan","","",26,null],[13,"LessThan","","",26,null],[13,"GreaterOrEqual","","",26,null],[13,"LessOrEqual","","",26,null],[4,"Statement","","Enum for statements.",null,null],[13,"Block","","",27,null],[13,"Expression","","",27,null],[13,"Assignment","","",27,null],[13,"WhileLoop","","",27,null],[13,"ForLoop","","",27,null],[13,"FnDef","","",27,null],[13,"ClassDef","","",27,null],[13,"TraitDef","","",27,null],[13,"EnumDef","","",27,null],[13,"ConstDef","","",27,null],[13,"Return","","",27,null],[13,"Break","","",27,null],[13,"Continue","","",27,null],[4,"Assigner","","Different types of assignments, one for mutability, the other for immutability.",null,null],[13,"Let","","",28,null],[13,"Var","","",28,null],[11,"clone","","",21,{"inputs":[{"name":"self"}],"output":{"name":"expr"}}],[11,"fmt","","",21,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",22,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",22,{"inputs":[{"name":"self"}],"output":{"name":"unaryoperator"}}],[11,"eq","","",22,{"inputs":[{"name":"self"},{"name":"unaryoperator"}],"output":{"name":"bool"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"unaryexpr"}}],[11,"clone","","",23,{"inputs":[{"name":"self"}],"output":{"name":"binaryoperator"}}],[11,"fmt","","",23,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",24,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",24,{"inputs":[{"name":"self"}],"output":{"name":"arithmeticoperator"}}],[11,"eq","","",24,{"inputs":[{"name":"self"},{"name":"arithmeticoperator"}],"output":{"name":"bool"}}],[11,"fmt","","",25,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",25,{"inputs":[{"name":"self"}],"output":{"name":"logicaloperator"}}],[11,"eq","","",25,{"inputs":[{"name":"self"},{"name":"logicaloperator"}],"output":{"name":"bool"}}],[11,"fmt","","",26,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",26,{"inputs":[{"name":"self"}],"output":{"name":"relationaloperator"}}],[11,"eq","","",26,{"inputs":[{"name":"self"},{"name":"relationaloperator"}],"output":{"name":"bool"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"binaryexpr"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"literal"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"identifier"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"call"}}],[11,"fmt","","",27,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",27,{"inputs":[{"name":"self"}],"output":{"name":"statement"}}],[11,"fmt","","",28,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",28,{"inputs":[{"name":"self"}],"output":{"name":"assigner"}}],[11,"eq","","",28,{"inputs":[{"name":"self"},{"name":"assigner"}],"output":{"name":"bool"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"assignment"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"block"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"condition"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"conditional"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"whileloop"}}],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"forloop"}}],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",13,{"inputs":[{"name":"self"}],"output":{"name":"functiondefinition"}}],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",14,{"inputs":[{"name":"self"}],"output":{"name":"classdeclaration"}}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",15,{"inputs":[{"name":"self"}],"output":{"name":"traitdeclaration"}}],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",16,{"inputs":[{"name":"self"}],"output":{"name":"enumdeclaration"}}],[11,"fmt","","",17,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",17,{"inputs":[{"name":"self"}],"output":{"name":"constant"}}],[11,"fmt","","",18,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",18,{"inputs":[{"name":"self"}],"output":{"name":"return"}}],[11,"fmt","","",19,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",19,{"inputs":[{"name":"self"}],"output":{"name":"break"}}],[11,"fmt","","",29,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",29,{"inputs":[{"name":"self"}],"output":{"name":"continue"}}],[11,"fmt","","",20,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",20,{"inputs":[{"name":"self"}],"output":{"name":"module"}}],[11,"new","","",20,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[11,"fmt","wright::parser","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"parser"}}],[11,"parse","","",0,{"inputs":[{"name":"self"}],"output":null}],[11,"new","","",0,{"inputs":[{"name":"string"},{"name":"string"}],"output":{"name":"self"}}],[11,"lex","","",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[0,"argparser","wright","The command line argument parser for Wright",null,null],[5,"argparse","wright::argparser","Parse arguments passed to the wright command. Returns `None` if there is no action to take after parsing arguments. Otherwise, it will return `Some(file)` where `file` is a String filename to be interpreted.",null,{"inputs":[{"name":"args"}],"output":{"name":"option"}}],[5,"version","","Prints version string for wright. Should be identical to cargo version information.",null,{"inputs":[],"output":null}],[5,"help","","Prints help information for wright",null,{"inputs":[],"output":null}],[0,"run","wright","",null,null],[5,"interpret_file","wright::run","Interprets the Wright file at the file name passed into the argument. Returns the operating system exit code (Generally 0 for a success, 1 for a failure.).",null,{"inputs":[{"name":"string"}],"output":{"name":"i32"}}],[0,"version","wright","",null,null],[5,"get_version","wright::version","`get_version()` returns Wright's version as a string. This should be identical to its version in cargo.",null,{"inputs":[],"output":{"name":"string"}}],[17,"VERSION","","`VERSION` const is a version constant in the form of a `&'static str`",null,null],[0,"interpreter","wright","Interpreter module.",null,null],[3,"Interpreter","wright::interpreter","Interpreter struct",null,null],[11,"fmt","","",30,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Constructor.",30,{"inputs":[{"name":"string"},{"name":"string"}],"output":{"name":"interpreter"}}],[11,"get_name","","File name accessor.",30,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"run","","Interpreter execution function",30,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[0,"lexer","wright","Lexer Module.",null,null],[3,"Lexer","wright::lexer","Lexer struct, which stores publicly a `tokens` field which is generated using the `lex` method.  Tokens will be an internal representation of source code, sliced in to parsable \"lexemes\" or \"tokens\".",null,null],[12,"tokens","","",31,null],[3,"LexerError","","Structure for lexer errors.",null,null],[12,"module_name","","",32,null],[12,"position","","",32,null],[12,"info","","",32,null],[12,"line","","",32,null],[0,"position","","Module used for tracking read-head position in file.",null,null],[3,"Position","wright::lexer::position","Position of the reading head in the file, indexed starting at 1. Mainly for user interfacing.",null,null],[12,"line","","",33,null],[12,"col","","",33,null],[11,"fmt","","",33,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",33,{"inputs":[{"name":"self"}],"output":{"name":"position"}}],[11,"default","","defaults to initial location",33,{"inputs":[],"output":{"name":"self"}}],[11,"new","","Constructor, setting read-head at beginning of file.",33,{"inputs":[],"output":{"name":"self"}}],[11,"increment_line","","Increments internal line counter.",33,{"inputs":[{"name":"self"}],"output":null}],[11,"increment_column","","Increments column.",33,{"inputs":[{"name":"self"}],"output":null}],[0,"char_tests","wright::lexer","Module of functions for checking characters.",null,null],[5,"is_digit","wright::lexer::char_tests","Checks if a char is a digit",null,{"inputs":[{"name":"char"}],"output":{"name":"bool"}}],[5,"is_hex_digit","","Checks if a char is a hexadecimal digit.",null,{"inputs":[{"name":"char"}],"output":{"name":"bool"}}],[5,"is_bin_digit","","Checks if a char is a binary digit.",null,{"inputs":[{"name":"char"}],"output":{"name":"bool"}}],[5,"is_alpha","","Checks if a char is in the alphabet.",null,{"inputs":[{"name":"char"}],"output":{"name":"bool"}}],[5,"is_alphanumeric","","Checks if a char is alphanumeric.",null,{"inputs":[{"name":"char"}],"output":{"name":"bool"}}],[5,"is_whitespace","","Checks if a char is whitespace.",null,{"inputs":[{"name":"char"}],"output":{"name":"bool"}}],[5,"is_symbol","","Checks if a character is a symbol in `lexer::Lexer::SYMBOLS`",null,{"inputs":[{"name":"char"}],"output":{"name":"bool"}}],[11,"fmt","wright::lexer","",31,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",31,{"inputs":[{"name":"self"}],"output":{"name":"lexer"}}],[11,"new","","Constructor. Content argument is source code written in wright.",31,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[11,"lex","","Tokenizes `self.source` and stores to `self.tokens`. Should operate at O(n). (n being the length of the wright file) #### Is completely loss-less. No source-code is lost in this conversion, it's all just split into parsable tokens. #### Has special cases. Tokens have these rules: * If a symbol in the `SYMBOLS` constant can be matched, it will be.     * If that symbol is a `//`, the rest of the line will be lexed into the same token. * If a token starts with a letter, it may have any combination of alphanumerics     and underscroes for the rest of it. * All others are turned into single-char tokens. ### These rules will change in future releases.",31,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"fmt","","",32,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",32,{"inputs":[{"name":"self"}],"output":{"name":"lexererror"}}],[11,"new","","Constructor.",32,{"inputs":[{"name":"position"},{"name":"string"}],"output":{"name":"self"}}],[11,"set_info","","Sets info string based on an expected character and the character that was found. Auto-generates error message.",32,{"inputs":[{"name":"self"},{"name":"char"},{"name":"option"}],"output":null}],[11,"set_info_as_vec","","Very similar to `set_info` however this method takes a `Vec<char>` argument, specifying that any of those characters would have been acceptable coming next.",32,{"inputs":[{"name":"self"},{"name":"vec"},{"name":"option"}],"output":null}],[11,"fmt","","",32,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}]],"paths":[[3,"Parser"],[4,"ParserError"],[3,"UnaryExpr"],[3,"BinaryExpr"],[3,"Literal"],[3,"Identifier"],[3,"Call"],[3,"Assignment"],[3,"Block"],[3,"Condition"],[3,"Conditional"],[3,"WhileLoop"],[3,"ForLoop"],[3,"FunctionDefinition"],[3,"ClassDeclaration"],[3,"TraitDeclaration"],[3,"EnumDeclaration"],[3,"Constant"],[3,"Return"],[3,"Break"],[3,"Module"],[4,"Expr"],[4,"UnaryOperator"],[4,"BinaryOperator"],[4,"ArithmeticOperator"],[4,"LogicalOperator"],[4,"RelationalOperator"],[4,"Statement"],[4,"Assigner"],[3,"Continue"],[3,"Interpreter"],[3,"Lexer"],[3,"LexerError"],[3,"Position"]]};
initSearch(searchIndex);
