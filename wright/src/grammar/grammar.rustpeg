use super::model::ast::*;
use super::model::Spanned;

bin_digit = [01]
dec_digit = [0-9]
oct_digit = [0-7]
hex_digit = [0-9a-fA-F]
newline = #quiet<"\r\n" / "\n" / "\r"> / #expected("NEWLINE")
whitespace = #quiet<[ \t\u{000C}\u{000B}\u{0085}\u{200E}\u{200F}\u{2028}\u{2029}] / newline>
alpha = [a-zA-Z]
alphanumeric = alpha / dec_digit

single_line_comment = #quiet<"//" (!newline .)* newline?>
multi_line_comment = #quiet<"/*" (.* multi_line_comment .*)* "*/">
doc_comment -> Structural<'input> = #quiet<"///" c:spanned<$((!newline .)*)> newline {Structural::Documentation(c)}>
multi_doc_comment -> Structural<'input> = #quiet<"/?" c:spanned<$((!"?/" .)*)> "?/" {Structural::Documentation(c)}>
comment = #quiet<single_line_comment / multi_line_comment>
ignored = #quiet<(whitespace / comment)+>

UNION = "union"
TYPE = "type"
TRAIT = "trait"
VAR = "var"
VAL = "val"
CLASS = "class"
COMPONENT = "component"
FUNC = "func"
IMPL = "impl"
USE = "use"
PUBLIC = "public"
PRIVATE = "private"
HIDDEN = "hidden"
PROTECTED = "protected"
WHERE = "where"
SELF_V = "self"
SELF_T = "Self"
BOOL = "bool"
U8 = "u8"
I8 = "i8"
U16 = "u16"
I16 = "i16"
CHAR = "char"
U32 = "u32"
I32 = "i32"
F32 = "f32"
U64 = "u64"
I64 = "i64"
F64 = "f64"
STR = "str"
VOID = "void"
TRUE = "true"
FALSE = "false"

visibility_modifier = PUBLIC / PRIVATE / HIDDEN / PROTECTED
var_modifier = VAR / VAL / COMPONENT

primitive_type = BOOL / primitive_number_type / CHAR / STR / VOID

primitive_number_type = U8 / I8 / U16 / I16 / U32 / U64 / I32 / I64 / F32 / F64

keyword =
    UNION /
    TYPE /
    TRAIT /
    var_modifier /
    CLASS /
    FUNC /
    IMPL /
    USE /
    visibility_modifier /
    SELF_V /
    SELF_T /
    primitive_type /
    TRUE /
    FALSE


spanned<T> = (start:#position inner:T end:#position { Spanned::new(inner, start, end) })
i_m<A> = (whitespace* (comment whitespace*)* AAA:A whitespace* (comment whitespace*)* {AAA})
i_r<A> = (AAA:A whitespace+ (comment whitespace*)* {AAA})
boxed<T> = box_v:T {Box::new(box_v)}
opt_ignore = whitespace* (comment whitespace*)*

identifier_str -> &'input str = #quiet<$(!keyword (alpha (alphanumeric / "_")*))> / #expected("IDENTIFIER")

visibility -> Spanned<VisibilityModifier> =
    spanned<s:$(visibility_modifier) {match s {
        "public" => VisibilityModifier::Public,
        "private" => VisibilityModifier::Private,
        "hidden" => VisibilityModifier::Hidden,
        "protected" => VisibilityModifier::Protected,
        other => panic!("Unrecognized visibility: {}", other),
    } }>

mod_visibility -> Option<Spanned<VisibilityModifier>> = i_r<visibility>?

ser_fmt<S, T, E, D> = (S VVV:i_m<spanned<T>>**D E {VVV})
ns_ser_fmt<S, T, E, D> = (S VVV:i_m<T>**D E {VVV})
generics_fmt<T> = ser_fmt<"<", T, ">", ",">
args_fmt<T> = ser_fmt<"(", T, ")", ",">
block_fmt<T> = ser_fmt<"{", T, "}", ",">
i_block_fmt<T> = ser_fmt<"{", T, "}", "">
ins_block_fmt<T> = ns_ser_fmt<"{", T, "}", "">
supers_fmt<T> = ser_fmt<"", T, "", "+">

generics -> GenericsDeclaration<'input> = g:generics_fmt<identifier_str> {GenericsDeclaration(g)}

type -> Type<'input> = t_primitive / t_user / t_array / t_self / t_fn

t_primitive -> Type<'input> =
    s:spanned<$(primitive_type)> { Type::Primitive(match s.inner {
        "bool" => PrimitiveType::Boolean,
        "u8" => PrimitiveType::U8,
        "i8" => PrimitiveType::I8,
        "u16" => PrimitiveType::U16,
        "i16" => PrimitiveType::I16,
        "char" => PrimitiveType::Character,
        "u32" => PrimitiveType::U32,
        "i32" => PrimitiveType::I32,
        "f32" => PrimitiveType::F32,
        "u64" => PrimitiveType::U64,
        "i64" => PrimitiveType::I64,
        "f64" => PrimitiveType::F64,
        "str" => PrimitiveType::Str,
        "void" => PrimitiveType::Void,
        other => panic!("Unrecognized primitive type: {}", other),
    })}

t_user -> Type<'input> = n:i_m<spanned<module_ref>> g:i_m<generics_fmt<type>?> {Type::User(n, match g {
    None => vec![],
    Some(l) => l,
})}

t_array -> Type<'input> =
    "[" t:i_m<spanned<type>> b:i_m<("," e:i_m<expression> {Box::new(e)})>? "]" {Type::Array(Box::new(t), b)}

t_self -> Type<'input> = SELF_T {Type::SelfType}

t_fn -> Type<'input> = i_m<FUNC> a:i_m<args_fmt<type>> r:("->" boxed<i_m<spanned<type>>>)? {Type::Function(a, r)}

var_type -> VarType = v:$(var_modifier) { match v {
    "var" => VarType::Var,
    "val" => VarType::Val,
    "component" => VarType::Component,
    other => panic!("Unrecognized variable type {}.", other),
}}

union_variant -> UnionVariant<'input> = n:i_m<spanned<identifier_str>> ":" t:i_m<spanned<type>> {UnionVariant(n, t)}

field_declaration -> FieldDeclaration<'input> =
    vt:i_r<spanned<var_type>>
    comp: i_r<spanned<COMPONENT>?>
    n:i_m<spanned<identifier_str>> ":"
    t:i_m<spanned<type>> {FieldDeclaration(vt, comp, n, t)}

component_item -> ComponentItem<'input> =
    (f: function_declaration {ComponentItem::Fn(f)}) /
    (c: constant_declaration {ComponentItem::Const(c)}) /
    (t: type_alias {ComponentItem::Type(t)})

fn_arg -> FnArg<'input> = vt:i_r<spanned<var_type>> n:i_m<spanned<$(identifier_str / SELF_V)>> t:(":" i_m<spanned<type>>)? {FnArg(vt, n, t)}

where_clause -> WhereClause<'input> =
    i_r<WHERE> w:i_m<ser_fmt<"",(
        b: i_m<spanned<type>>
        ":"
        s: i_m<spanned<supers_fmt<type>>>
        {(b, s)}
    ),"", ",">> {WhereClause(w)}

mod_generics -> Option<Spanned<GenericsDeclaration<'input>>> = i_m<spanned<generics>?>
mod_supers -> Vec<Spanned<Type<'input>>> = i_m<(&EXTENDS i_r<EXTENDS> t:supers_fmt<type> {t}) / {vec![]}>

pub parse_program -> Module<'input> = m:i_m<top_level_structural>**"" {Module(m)}

top_level_structural -> Structural<'input> =
    import /
    union_declaration /
    class_declaration /
    component_declaration /
    s_function_declaration /
    trait_declaration /
    s_constant_declaration /
    impl_block /
    s_type_alias /
    doc_comment /
    multi_doc_comment

import -> Structural<'input> = v:mod_visibility i_r<IMPORT> e:spanned<module_ref> i_m<";"> {Structural::Import(v, e)}

module_ref -> ModuleRef<'input> =
    (i:spanned<identifier_str> {ModuleRef::Term(i)}) /
    (i_m<"::"> m:boxed<spanned<module_ref>> {ModuleRef::Inner(m)})

union_declaration -> Structural<'input> =
    visibility:mod_visibility
    s:mod_structural
    i_r<UNION>
    n:i_m<spanned<identifier_str>>
    g:mod_generics
    variants: i_m<block_fmt<union_variant>>
    {Structural::UnionDeclaration {
        visibility,
        modifiers: s,
        name: n,
        generics: g,
        variants,
    }}

class_declaration -> Structural<'input> =
    v: mod_visibility
    s: mod_structural
    i_r<CLASS>
    n: i_m<spanned<identifier_str>>
    g: mod_generics
    fields: i_m<block_fmt<field_declaration>>
    {Structural::ClassDeclaration {
        modifiers: s,
        visibility: v,
        name: n,
        generics: g,
        fields,
    }}

component_declaration -> Structural<'input> =
    v: mod_visibility
    s: mod_structural
    i_r<COMPONENT>
    n: i_m<spanned<identifier_str>>
    g: mod_generics
    supers: mod_supers
    i_m<"=">
    eq: i_m<spanned<type>>
    items: i_m<ins_block_fmt<component_item>>
    {Structural::ComponentDeclaration {
        modifiers: s,
        visibility: v,
        name: n,
        generics: g,
        supers,
        alias: eq,
        items
    }}

trait_declaration -> Structural<'input> =
    v: mod_visibility
    s: mod_structural
    i_r<TRAIT>
    n: i_m<spanned<identifier_str>>
    g: mod_generics
    supers: mod_supers
    items: i_m<ins_block_fmt<component_item>>
    {Structural::TraitDeclaration{
        modifiers: s,
        visibility: v,
        name: n,
        generics: g,
        supers,
        items
    }}

impl_block -> Structural<'input> =
    i_m<IMPL>
    g: mod_generics
    ty_a: i_r<spanned<type>>
    ty_b: (i_r<FOR> t:i_m<spanned<type>> {t})?
    w_c: i_m<where_clause?>
    items: i_m<ins_block_fmt<component_item>>
    {if let Some(t) = ty_b {
        Structural::Impl {
            generics: g,
            base: t,
            ty: Some(ty_a),
            where_clause: w_c,
            items
        }
    } else {
        Structural::Impl {
            generics: g,
            base: ty_a,
            ty: None,
            where_clause: w_c,
            items
        }
    }}

s_function_declaration -> Structural<'input> = f:function_declaration {Structural::Function(f)}
s_type_alias -> Structural<'input> = t:type_alias {Structural::Type(t)}

function_declaration -> FunctionDeclaration<'input> =
    v: mod_visibility
    i_r<FUNC>
    n: i_m<spanned<identifier_str>>
    g: mod_generics
    a: args_fmt<fn_arg>
    r:(i_m<"->"> i_m<spanned<type>>)?
    code: i_m<(
        (";" {None}) /
        ("=" e:i_m<expression> {Some(e)})
    )> {FunctionDeclaration {
        modifiers: s,
        visibility: v,
        name: n,
        generics: g,
        return_type: r,
        args: a,
        code
    }}

type_alias -> TypeAlias<'input> =
    v: mod_visibility
    i_r<TYPE>
    ty: i_m<spanned<type>>
    al: ("=" i_m<spanned<type>>)?
    ";"
    {TypeAlias(v,ty,al)}

expression -> Spanned<Expression<'input>> =
    binary_expr /
    function_call /
    identifier /
    self_identifier /
    literal_int /
    literal_bool /
    literal_float /
    literal_string /
    literal_char /
    unary_expr /
    lambda

identifier -> Spanned<Expression<'input>> = spanned<i:identifier_str {Expression::Identifier(i)}>
self_identifier -> Spanned<Expression<'input>> = spanned<(SELF_V {Expression::SelfIdentifier})>

literal_int -> Spanned<Expression<'input>> = spanned<(n:(bin_int_literal / hex_int_literal / oct_int_literal / dec_int_literal) {Expression::LitInt(n)})>
bin_int_literal -> LiteralParse<u64> = s:$("0b" bin_digit+) {s.parse::<u64>()}
oct_int_literal -> LiteralParse<u64> = s:$("0o" oct_digit+) {s.parse::<u64>()}
dec_int_literal -> LiteralParse<u64> = s:$(dec_digit+) {s.parse::<u64>()}
hex_int_literal -> LiteralParse<u64> = s:$("0x" hex_digit+) {s.parse::<u64>()}

literal_float -> Spanned<Expression<'input>> = spanned<(s:$(dec_digit+ "." dec_digit*) {Expression::LitFloat(s.parse::<f64>())})>

literal_string -> Spanned<Expression<'input>> = spanned<(s:("\"" is: $((dq_escape_char / (!"\"" .))* ) "\"" {is}) {Expression::LitStr(s)} )>
dq_escape_char = "\\\"" / "\\\\"

literal_char -> Spanned<Expression<'input>> = spanned<(c:("'" s:$(.) "'"{s.parse::<char>()}) {Expression::LitChar(c)} )>

literal_bool -> Spanned<Expression<'input>> = spanned<(b:(s:$(TRUE / FALSE) {s.parse::<bool>()}) {Expression::LitBool(b)})>

binary_expr -> Spanned<Expression<'input>> = infix_binary_expr / subscript

infix_binary_expr -> Spanned<Expression<'input>> = #infix<expression> {
    #L  a ";" b {Spanned::<Expression>::combine(a,b,BinaryOp::Semicolon)}
    #R  a "=" b {Spanned::<Expression>::combine(a,b,BinaryOp::Assign)}
        a "+=" b {Spanned::<Expression>::assign_combine(a,b,BinaryOp::Add)}
        a "-=" b {Spanned::<Expression>::assign_combine(a,b,BinaryOp::Subtract)}
        a "*=" b {Spanned::<Expression>::assign_combine(a,b,BinaryOp::Multiply)}
        a "/=" b {Spanned::<Expression>::assign_combine(a,b,BinaryOp::Divide)}
        a "%=" b {Spanned::<Expression>::assign_combine(a,b,BinaryOp::Mod)}
        a "|=" b {Spanned::<Expression>::assign_combine(a,b,BinaryOp::OR)}
        a "&=" b {Spanned::<Expression>::assign_combine(a,b,BinaryOp::AND)}
        a "^=" b {Spanned::<Expression>::assign_combine(a,b,BinaryOp::XOR)}
        a ">>=" b {Spanned::<Expression>::assign_combine(a,b,BinaryOp::RShift)}
        a "<<=" b {Spanned::<Expression>::assign_combine(a,b,BinaryOp::LShift)}
        a ">>>=" b {Spanned::<Expression>::assign_combine(a,b,BinaryOp::URShift)}
    #L  a "||" b {Spanned::<Expression>::combine(a,b,BinaryOp::LOR)}
    #L  a "&&" b {Spanned::<Expression>::combine(a,b,BinaryOp::LAND)}
    #L  a "|" b {Spanned::<Expression>::combine(a,b,BinaryOp::OR)}
    #L  a "^" b {Spanned::<Expression>::combine(a,b,BinaryOp::XOR)}
    #L  a "&" b {Spanned::<Expression>::combine(a,b,BinaryOp::AND)}
    #L  a "==" b {Spanned::<Expression>::combine(a,b,BinaryOp::EQ)}
        a "!=" b {Spanned::<Expression>::combine(a,b,BinaryOp::NE)}
    #L  a "<" b {Spanned::<Expression>::combine(a,b,BinaryOp::LT)}
        a "<=" b {Spanned::<Expression>::combine(a,b,BinaryOp::LTE)}
        a ">" b {Spanned::<Expression>::combine(a,b,BinaryOp::GT)}
        a ">=" b {Spanned::<Expression>::combine(a,b,BinaryOp::GTE)}
    #L  a ".." b {Spanned::<Expression>::combine(a,b,BinaryOp::Range)}
    #L  a ">>" b {Spanned::<Expression>::combine(a,b,BinaryOp::RShift)}
        a "<<" b {Spanned::<Expression>::combine(a,b,BinaryOp::LShift)}
        a ">>>" b {Spanned::<Expression>::combine(a,b,BinaryOp::URShift)}
    #L  a "+" b {Spanned::<Expression>::combine(a,b,BinaryOp::Add)}
        a "-" b {Spanned::<Expression>::combine(a,b,BinaryOp::Subtract)}
    #L  a "*" b {Spanned::<Expression>::combine(a,b,BinaryOp::Multiply)}
        a "/" b {Spanned::<Expression>::combine(a,b,BinaryOp::Divide)}
        a "%" b {Spanned::<Expression>::combine(a,b,BinaryOp::Mod)}
    #L  a "." b {Spanned::<Expression>::combine(a,b,BinaryOp::Dot)}
}

subscript -> Spanned<Expression<'input>> =
    spanned<i_m<
        a: boxed<spanned<expression>>
        i_m<"[">
        b: boxed<spanned<expression>>
        i_m<"]">
        {Expression::BinaryExpr(BinaryOp::Subscript, a, b)}>>

//function_call -> Spanned<Expression<'input>> =