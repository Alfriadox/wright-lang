//! Command line app generated by clap.
use clap::{Arg, App, AppSettings, Values};

use std::process::exit;

use std::result::Result;

use exitcode::ExitCode;

use wright::{
    Emit,
    Wright
};


/// Create and return the Wright command line app via [clap.rs](https://clap.rs).
pub fn get_wright_app<'a, 'b>() -> App<'a, 'b> {
    App::new("Wright")
        .setting(AppSettings::ColorAlways)
        .version(env!("CARGO_PKG_VERSION"))
        .author(env!("CARGO_PKG_AUTHORS"))
        .about("The Wright programming language interpreter and compiler.")
        .arg(Arg::with_name("INPUT")
            .help("Input wright file(s).")
            .multiple(true)
            .required_unless("INTERACTIVE")
        )
        .arg(Arg::with_name("RUN")
            .help("Runs input wright file rather than compiling it.")
            .case_insensitive(true)
            .short("r")
            .long("run")
        )
        .arg(Arg::with_name("INTERACTIVE")
            .help("Start an interactive wright session.")
            .case_insensitive(true)
            .short("i")
            .long("interactive")
        )
        .arg(Arg::with_name("EMIT")
            .short("e")
            .long("emit")
            .help("Prints intermediate representation(s).")
            .takes_value(true)
            .possible_values(&["tokens", "ast"])
            .use_delimiter(true)
            .multiple(true)
        )
        .arg(Arg::with_name("VERBOSE")
            .short("v")
            .long("verbose")
            .help("Prints additional information.")
        )
}

fn main() {
    let matches = get_wright_app().get_matches();
    let filenames = matches
        .values_of("INPUT")
        .unwrap_or(Values::default())
        .collect();
    let mut emits: Vec<Emit> = Vec::with_capacity(2);
    for v in matches.values_of("EMIT").unwrap_or(Values::default()) {
        emits.push(match v {
            "tokens"  => Emit::Tokens,
            "ast"     => Emit::AbstractSyntaxTree,
            other => panic!("{} should not be a possible emit option.", other),
        });
    }
    let mut wright = Wright::new();
    wright
        .set_verbose(matches.is_present("VERBOSE"))
        .set_interactive(matches.is_present("INTERACTIVE"))
        .set_emits(emits);
    if wright.add_files(filenames).is_err() {
        exit(exitcode::NOINPUT);
    }
    exit(wright.call());
}
