var searchIndex = {};
searchIndex["wright"] = {"doc":"","items":[[0,"parser","wright","Parser module for Wright. Includes preliminary lexer function.",null,null],[3,"Parser","wright::parser","Parser struct.",null,null],[12,"module","","",0,null],[12,"source","","",0,null],[12,"lexer","","",0,null],[4,"ParserError","","",null,null],[0,"ast","","Abstract Syntax Tree Representation",null,null],[3,"UnaryExpr","wright::parser::ast","Unary Expression.",null,null],[12,"operator","","",1,null],[12,"right","","",1,null],[3,"BinaryExpr","","Binary Expression.",null,null],[12,"left","","",2,null],[12,"operator","","",2,null],[12,"right","","",2,null],[3,"Sub","","Subfield access expression. (i.e. \"left.right\")",null,null],[12,"left","","",3,null],[12,"right","","",3,null],[3,"Cast","","Cast expression struct (i.e. \"value to type\")",null,null],[12,"value","","",4,null],[12,"to_type","","",4,null],[3,"Literal","","Literal struct.",null,null],[12,"literal","","",5,null],[3,"Identifier","","Identifier struct.",null,null],[12,"id","","",6,null],[3,"Type","","Type struct.",null,null],[12,"id","","",7,null],[12,"type_parameters","","",7,null],[3,"Call","","Function call.",null,null],[12,"callee","","",8,null],[12,"args","","",8,null],[3,"Assignment","","Assignment statement.",null,null],[12,"left","","",9,null],[12,"assign_type","","",9,null],[12,"right","","",9,null],[12,"declared_type","","",9,null],[3,"Block","","Block of statements",null,null],[12,"statements","","",10,null],[3,"Condition","","Single conditional statement.",null,null],[12,"condition","","",11,null],[12,"block","","",11,null],[3,"Conditional","","Conditional block",null,null],[12,"conditions","","",12,null],[3,"WhileLoop","","While loop struct.",null,null],[12,"id","","",13,null],[12,"condition","","",13,null],[12,"block","","",13,null],[3,"ForLoop","","For loop struct.",null,null],[12,"id","","",14,null],[12,"assignment","","",14,null],[12,"source_var","","",14,null],[12,"block","","",14,null],[3,"FunctionDefinition","","Function defining struct.",null,null],[12,"declared_type","","",15,null],[12,"id","","",15,null],[12,"args","","",15,null],[12,"block","","",15,null],[3,"ClassDeclaration","","Class declaration struct.",null,null],[12,"generics","","",16,null],[12,"id","","",16,null],[12,"traits_implemented","","",16,null],[12,"fields","","",16,null],[3,"TraitDeclaration","","Trait declaration struct.",null,null],[12,"generics","","",17,null],[12,"id","","",17,null],[12,"requires","","",17,null],[12,"block","","",17,null],[3,"EnumDeclaration","","Enum (tagged union) declaration struct.",null,null],[12,"generics","","",18,null],[12,"id","","",18,null],[12,"variants","","",18,null],[3,"Constant","","Constant struct.",null,null],[12,"id","","",19,null],[12,"declared_type","","",19,null],[12,"val","","",19,null],[3,"Return","","Return statement struct.",null,null],[12,"val","","",20,null],[3,"LoopAnnotation","","Loop annotation struct",null,null],[12,"id","","",21,null],[3,"Break","","Break statement struct.",null,null],[12,"id","","",22,null],[3,"Continue","","Continue statement struct.",null,null],[12,"id","","",23,null],[3,"Module","","Module struct Module is not in `Statement` because users should not be able to define modules in a file. Each Wright file should be it's own independent Module.",null,null],[12,"id","","",24,null],[12,"content","","",24,null],[4,"Expression","","Expression enum.",null,null],[13,"Unary","","",25,null],[13,"Binary","","",25,null],[13,"Literal","","",25,null],[13,"Identifier","","",25,null],[13,"FunctionCall","","",25,null],[13,"Sub","","",25,null],[13,"Cast","","",25,null],[4,"UnaryOperator","","Unary Operators",null,null],[13,"Not","","",26,null],[13,"Negative","","",26,null],[13,"BitwiseNot","","",26,null],[4,"BinaryOperator","","Enum representing binary operators.",null,null],[13,"Arithmetic","","",27,null],[13,"Logical","","",27,null],[13,"Relational","","",27,null],[4,"ArithmeticOperator","","Arithmetic Operators",null,null],[13,"Add","","",28,null],[13,"Subtract","","",28,null],[13,"Multiply","","",28,null],[13,"Divide","","",28,null],[13,"Modulo","","",28,null],[13,"BitwiseAnd","","",28,null],[13,"BitwiseOr","","",28,null],[13,"BitwiseXor","","",28,null],[13,"LeftShift","","",28,null],[13,"RightShift","","",28,null],[13,"Increment","","",28,null],[13,"Decrement","","",28,null],[4,"LogicalOperator","","Logical Operators",null,null],[13,"And","","",29,null],[13,"Or","","",29,null],[13,"Xor","","",29,null],[13,"ShortAnd","","",29,null],[13,"ShortOr","","",29,null],[4,"RelationalOperator","","Relational Operators",null,null],[13,"Equal","","",30,null],[13,"NotEqual","","",30,null],[13,"GreaterThan","","",30,null],[13,"LessThan","","",30,null],[13,"GreaterOrEqual","","",30,null],[13,"LessOrEqual","","",30,null],[4,"Statement","","Enum for statements.",null,null],[13,"Block","","",31,null],[13,"Expression","","",31,null],[13,"Assignment","","",31,null],[13,"WhileLoop","","",31,null],[13,"ForLoop","","",31,null],[13,"FnDef","","",31,null],[13,"ClassDef","","",31,null],[13,"TraitDef","","",31,null],[13,"EnumDef","","",31,null],[13,"ConstDef","","",31,null],[13,"Return","","",31,null],[13,"Break","","",31,null],[13,"Continue","","",31,null],[13,"SingleCondition","","",31,null],[13,"Conditional","","",31,null],[4,"Assigner","","Different types of assignments, one for mutability, the other for immutability.",null,null],[13,"Let","","",32,null],[13,"Var","","",32,null],[11,"clone","","",25,{"inputs":[{"name":"self"}],"output":{"name":"expression"}}],[11,"fmt","","",25,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",26,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",26,{"inputs":[{"name":"self"}],"output":{"name":"unaryoperator"}}],[11,"eq","","",26,{"inputs":[{"name":"self"},{"name":"unaryoperator"}],"output":{"name":"bool"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"unaryexpr"}}],[11,"clone","","",27,{"inputs":[{"name":"self"}],"output":{"name":"binaryoperator"}}],[11,"fmt","","",27,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",28,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",28,{"inputs":[{"name":"self"}],"output":{"name":"arithmeticoperator"}}],[11,"eq","","",28,{"inputs":[{"name":"self"},{"name":"arithmeticoperator"}],"output":{"name":"bool"}}],[11,"fmt","","",29,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",29,{"inputs":[{"name":"self"}],"output":{"name":"logicaloperator"}}],[11,"eq","","",29,{"inputs":[{"name":"self"},{"name":"logicaloperator"}],"output":{"name":"bool"}}],[11,"fmt","","",30,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",30,{"inputs":[{"name":"self"}],"output":{"name":"relationaloperator"}}],[11,"eq","","",30,{"inputs":[{"name":"self"},{"name":"relationaloperator"}],"output":{"name":"bool"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"binaryexpr"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"sub"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"cast"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"literal"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"identifier"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"type"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"call"}}],[11,"fmt","","",31,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",31,{"inputs":[{"name":"self"}],"output":{"name":"statement"}}],[11,"fmt","","",32,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",32,{"inputs":[{"name":"self"}],"output":{"name":"assigner"}}],[11,"eq","","",32,{"inputs":[{"name":"self"},{"name":"assigner"}],"output":{"name":"bool"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"assignment"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"block"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"condition"}}],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"conditional"}}],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",13,{"inputs":[{"name":"self"}],"output":{"name":"whileloop"}}],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",14,{"inputs":[{"name":"self"}],"output":{"name":"forloop"}}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",15,{"inputs":[{"name":"self"}],"output":{"name":"functiondefinition"}}],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",16,{"inputs":[{"name":"self"}],"output":{"name":"classdeclaration"}}],[11,"fmt","","",17,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",17,{"inputs":[{"name":"self"}],"output":{"name":"traitdeclaration"}}],[11,"fmt","","",18,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",18,{"inputs":[{"name":"self"}],"output":{"name":"enumdeclaration"}}],[11,"fmt","","",19,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",19,{"inputs":[{"name":"self"}],"output":{"name":"constant"}}],[11,"fmt","","",20,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",20,{"inputs":[{"name":"self"}],"output":{"name":"return"}}],[11,"fmt","","",21,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",21,{"inputs":[{"name":"self"}],"output":{"name":"loopannotation"}}],[11,"fmt","","",22,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",22,{"inputs":[{"name":"self"}],"output":{"name":"break"}}],[11,"fmt","","",23,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",23,{"inputs":[{"name":"self"}],"output":{"name":"continue"}}],[11,"fmt","","",24,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",24,{"inputs":[{"name":"self"}],"output":{"name":"module"}}],[11,"new","","",24,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[11,"fmt","wright::parser","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"parser"}}],[11,"parse","","",0,{"inputs":[{"name":"self"}],"output":null}],[11,"new","","",0,{"inputs":[{"name":"string"},{"name":"string"}],"output":{"name":"self"}}],[11,"lex","","",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[0,"argparser","wright","The command line argument parser for Wright",null,null],[5,"argparse","wright::argparser","Parse arguments passed to the wright command. Returns `None` if there is no action to take after parsing arguments. Otherwise, it will return `Some(file)` where `file` is a String filename to be interpreted.",null,{"inputs":[{"name":"args"}],"output":{"name":"option"}}],[5,"version","","Prints version string for wright. Should be identical to cargo version information.",null,{"inputs":[],"output":null}],[5,"help","","Prints help information for wright",null,{"inputs":[],"output":null}],[0,"run","wright","",null,null],[5,"interpret_file","wright::run","Interprets the Wright file at the file name passed into the argument. Returns the operating system exit code (Generally 0 for a success, 1 for a failure.).",null,{"inputs":[{"name":"string"}],"output":{"name":"i32"}}],[0,"version","wright","",null,null],[5,"get_version","wright::version","`get_version()` returns Wright's version as a string. This should be identical to its version in cargo.",null,{"inputs":[],"output":{"name":"string"}}],[17,"VERSION","","`VERSION` const is a version constant in the form of a `&'static str`",null,null],[0,"interpreter","wright","Interpreter module.",null,null],[3,"Interpreter","wright::interpreter","Interpreter struct",null,null],[11,"fmt","","",33,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Constructor.",33,{"inputs":[{"name":"string"},{"name":"string"}],"output":{"name":"interpreter"}}],[11,"get_name","","File name accessor.",33,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"run","","Interpreter execution function",33,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[0,"lexer","wright","Lexer Module.",null,null],[3,"Lexer","wright::lexer","Lexer struct, which stores publicly a `tokens` field which is generated using the `lex` method.  Tokens will be an internal representation of source code, sliced in to parsable \"lexemes\" or \"tokens\".",null,null],[12,"tokens","","",34,null],[0,"position","","Module used for tracking read-head position in file.",null,null],[3,"Position","wright::lexer::position","Position of the reading head in the file, indexed starting at 1. Mainly for user interfacing.",null,null],[12,"line","","",35,null],[12,"col","","",35,null],[11,"fmt","","",35,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",35,{"inputs":[{"name":"self"}],"output":{"name":"position"}}],[11,"default","","defaults to initial location",35,{"inputs":[],"output":{"name":"self"}}],[11,"new","","Constructor, setting read-head at beginning of file.",35,{"inputs":[],"output":{"name":"self"}}],[11,"increment_line","","Increments internal line counter.",35,{"inputs":[{"name":"self"}],"output":null}],[11,"increment_column","","Increments column.",35,{"inputs":[{"name":"self"}],"output":null}],[11,"decrement_column","","Decrements column. Will not let column fall below 1.",35,{"inputs":[{"name":"self"}],"output":null}],[0,"char_tests","wright::lexer","Module of functions for checking characters.",null,null],[5,"is_digit","wright::lexer::char_tests","Checks if a char is a digit",null,{"inputs":[{"name":"char"}],"output":{"name":"bool"}}],[5,"is_hex_digit","","Checks if a char is a hexadecimal digit.",null,{"inputs":[{"name":"char"}],"output":{"name":"bool"}}],[5,"is_bin_digit","","Checks if a char is a binary digit.",null,{"inputs":[{"name":"char"}],"output":{"name":"bool"}}],[5,"is_alpha","","Checks if a char is in the alphabet.",null,{"inputs":[{"name":"char"}],"output":{"name":"bool"}}],[5,"is_alphanumeric","","Checks if a char is alphanumeric.",null,{"inputs":[{"name":"char"}],"output":{"name":"bool"}}],[5,"is_whitespace","","Checks if a char is whitespace.",null,{"inputs":[{"name":"char"}],"output":{"name":"bool"}}],[5,"is_symbol","","Checks if a character is a symbol in `lexer::Lexer::SYMBOLS`",null,{"inputs":[{"name":"char"}],"output":{"name":"bool"}}],[0,"error","wright::lexer","Module for defining, tracking, and printing lexer related errors.",null,null],[3,"LexerError","wright::lexer::error","Structure for lexer errors.",null,null],[11,"fmt","","",36,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",36,{"inputs":[{"name":"self"}],"output":{"name":"lexererror"}}],[11,"new","","Constructor. Defaults module name to \"AnonymousModule\". Defaults info name to \"There was an error while lexing.\". Use `set_module_name` and the info setter methods to change this.",36,{"inputs":[{"name":"position"},{"name":"string"}],"output":{"name":"self"}}],[11,"set_info","","Sets info string based on an expected character and the character that was found. Auto-generates error message. Follows builder style.",36,{"inputs":[{"name":"self"},{"name":"char"},{"name":"option"}],"output":{"name":"self"}}],[11,"set_info_as_string","","Very similar to `set_info` however it takes a `String` argument. Sets info string based on a string and the character that was found. Automatically generates an error message. Follows builder style.",36,{"inputs":[{"name":"self"},{"name":"str"},{"name":"option"}],"output":{"name":"self"}}],[11,"set_module_name","","Sets the module name used by the error reporting and formatting system.",36,{"inputs":[{"name":"self"},{"name":"string"}],"output":null}],[11,"set_info_as_vec","","Very similar to `set_info` however this method takes a `Vec<char>` argument, specifying that any of those characters would have been acceptable coming next. Automatically generates an error message. Follows builder style.",36,{"inputs":[{"name":"self"},{"name":"vec"},{"name":"option"}],"output":{"name":"self"}}],[11,"set_info_raw","","Very similar to `set_info` however it takes a `String` argument. Sets info to a string directly. Follows builder style.",36,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"self"}}],[11,"fmt","","",36,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","wright::lexer","",34,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",34,{"inputs":[{"name":"self"}],"output":{"name":"lexer"}}],[18,"SYMBOLS","","Constant containing all Strings that can represent any symbol or operator. Length of every symbol is 2 characters at most. Not all symbols currently have functionality in the wright language.",34,null],[11,"new","","Constructor. Content argument is source code written in wright.",34,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[11,"lex","","Tokenizes `self.source` and stores to `self.tokens`. #### Is completely loss-less. No source-code is lost in this conversion, it's all just split into parsable tokens. Note that this lexing follows the rules of the Wright language syntax, detailed in the Wright book docs.",34,{"inputs":[{"name":"self"}],"output":{"name":"result"}}]],"paths":[[3,"Parser"],[3,"UnaryExpr"],[3,"BinaryExpr"],[3,"Sub"],[3,"Cast"],[3,"Literal"],[3,"Identifier"],[3,"Type"],[3,"Call"],[3,"Assignment"],[3,"Block"],[3,"Condition"],[3,"Conditional"],[3,"WhileLoop"],[3,"ForLoop"],[3,"FunctionDefinition"],[3,"ClassDeclaration"],[3,"TraitDeclaration"],[3,"EnumDeclaration"],[3,"Constant"],[3,"Return"],[3,"LoopAnnotation"],[3,"Break"],[3,"Continue"],[3,"Module"],[4,"Expression"],[4,"UnaryOperator"],[4,"BinaryOperator"],[4,"ArithmeticOperator"],[4,"LogicalOperator"],[4,"RelationalOperator"],[4,"Statement"],[4,"Assigner"],[3,"Interpreter"],[3,"Lexer"],[3,"Position"],[3,"LexerError"]]};
initSearch(searchIndex);
