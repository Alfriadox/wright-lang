//! Command line app generated by clap.
use clap::{
    Arg,
    App,
    AppSettings
};

use std::process::exit;

use wright::{
    Emit,
    call_files
};


/// Create and return the Wright command line app via [clap.rs](https://clap.rs).
pub fn get_wright_app<'a, 'b>() -> App<'a, 'b> {
    App::new("Wright")
        .setting(AppSettings::ColorAlways)
        .version(env!("CARGO_PKG_VERSION"))
        .author(env!("CARGO_PKG_AUTHORS"))
        .about("The Wright programming language interpreter and compiler.")
        .arg(Arg::with_name("INPUT")
            .help("Input wright file(s).")
            .required(true)
            .multiple(true)
        )
        .arg(Arg::with_name("RUN")
            .help("Runs input wright file rather than compiling it.")
            .case_insensitive(true)
            .short("r")
            .long("run")
        )
        .arg(Arg::with_name("EMIT")
            .short("e")
            .long("emit")
            .help("Prints intermediate representation(s).")
            .takes_value(true)
            .possible_values(&["tokens", "ast"])
            .use_delimiter(true)
            .multiple(true)
        )
        .arg(Arg::with_name("VERBOSE")
            .short("v")
            .long("verbose")
            .help("Prints additional information about program execution.")
        )
}

fn main() {
    let matches = get_wright_app().get_matches();
    let filenames = matches.values_of("INPUT").unwrap().collect();
    let mut emits: Vec<Emit> = Vec::with_capacity(2);
    if matches.is_present("EMIT") {
        for v in matches.values_of("EMIT").unwrap() {
            emits.push(match v {
                "tokens"  => Emit::Tokens,
                "ast"     => Emit::AbstractSyntaxTree,
                other => panic!("{} should not be a possible emit option.", other),
            });
        }
    }
    exit(call_files(filenames, matches.is_present("RUN"), emits, matches.is_present("VERBOSE")))
}
